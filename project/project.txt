一、步骤：
1. 安装脚手架vue-cli: npm install @vue/cli 或者 yarn global add @vue/cli
2. 在项目文件夹中创建项目: vue init webpack 或 vue init 项目名 或 vue create 项目名  (vue --help 查看vue命令)
3. 创建项目过程中会让选择一些选项: 环境要选择Runtime + Compiler: recommended for most users、工具选择npm或yarn都可以
4. 启动项目试试: yarn start (会启动一个服务，可在浏览器浏览开发的项目)
5. build一下试试: yarn run build （会build出一个dist文件夹，此文件夹就是开发完成后部署到服务器上的项目）
6. src/main.js与根目录下的index.html文件相对应,main.js中首先要import Vue from 'vue'，后面要用什么就再引入什么,main.js中的new Vue()是定义了项目的根组件
7. 路由(/router/index.js)：a.引入vue、b.引入vue-router、c.引入各个单文件组件、 d.Vue.use一下引进来的vue-router、 
   e.new一下引进来的vue-router并配置routes、 f.export default一下new出来的vue-router的实例、 g.在用路由的地方引入并使用、
   h.在页面上相应的地方写上<router-view></router-view>标签(称为插座)、 i.点击进行路由跳转的标签为<router-link to=""></router-link>
   注意：在根组件里注入router后，在任何组件里都可以使用router-view标签和router-link标签

安装（vue-cli3.0）：
1. 如果您在vue-cli全局安装了以前的(1.x或2.0)软件包，则需要先将其卸载：npm uninstall vue-cli -g 或 yarn global remove vue-cli 或  sudo npm uninstall vue-cli -g 
2. 安装vue cli3.0，包名称由vue-cli改为@vue/cli： npm install @vue/cli 或者 yarn global add @vue/cli 
3. 创建项目：vue create 项目名 --> please pick a present选择Manually select features --> 选中Babel、Router、Vuex、CSS（将Linter/Formatter的选中取消）
            --> 选择Sass/SCSS --> 选择In dedicated config files
4. 启动项目试试: yarn serve
5. build一下试试: yarn run build （会build出一个dist文件夹，此文件夹就是开发完成后部署到服务器上的项目）
6. 在vue-cli3.0搭建出来的项目中配置代理：在根目录下创建vue.config.js --> module.exports = {devServer: {proxy: {'/api': {target: '', changeOrigin: true}}}}

本地安装（vue-cli可在本地安装，这样当你的项目分享给别人时就不依赖于别人的电脑全局也要安装vue-cli了，只是在本地启用命令即可）：
1. yarn add @vue/cli
2. 在package.json文件中添加 "scripts":{"vue": "vue"}
3. 执行yarn run vue --help 查看命令
4. 创建项目：yarn run vue create 项目名



二、知识点：
1. 项目结构中有一个static文件夹，此文件夹中有一个.gitkeep文件，文件没有内容，这个文件是为了static文件夹做git同步用的。因为空文件夹是无法通过git
   提交的，所以要有一个文件即使是没有内容的文件就可以将static文件夹做git同步了
2. vue项目中的.vue文件叫做单文件组件（结构、逻辑和样式都写在此文件中）
3. <router-link tag="li" :to="{name:'home'}" active-class="active"></router-link>  tag是将此标签经编译后会变成li标签、active-class是添加此标签被选中后的样式类名
4. 路由守卫：
   a. beforeRouteEnter(to, from, next){ //进入守卫(不能在事件中直接访问this)（写在需要守卫的组件中，与组件的生命周期钩子平级）
       if(login){
           //next()  //进入页面,不写next()则路由将不会切换
           next((vm) => { //vm当前组件的实例(this)
               console.log(vm)
           })
       }else{
           alert('没有登陆，不能进入此页面')
       }
   }
   b. beforeRouteLeave(to, from, next){next()} //离开守卫(可在事件中直接访问this) （to是将要切换到的那个路由的信息对象，from是切换的前一个路由的信息对象）
   c. beforeRouteUpdate(to, from, next){next()} //在当前路由改变但该组件被复用时触发，如：detail/1切换到detail/2 (可在事件中直接访问this)
5. 在组件中获取当前路由：this.$route.path
6. v-for和v-if用在统一标签内会有优先级的问题(v-for优先)，所以要在外层写一个template标签，把v-if放在template标签上
7. v-for循环一个数字：v-for="(n, i) of 10", n -> 1,2,3,4,5,6,7,8,9,10; i -> 0,1,2,3,4,5,6,7,8,9
8. 绑定回车事件：@keyup.enter=""
9. 编程式导航：
   a. this.$router.push('home')  //字符串
   b. this.$router.push({path: 'home'})  //对象
   c. this.$router.push({name: 'home', params{id: 2}})  //命名的路由
   d. this.$router.push({path: 'home', query: {plan: 'private'}})  //带查询参数，变成：/home?plan=private，在跳转后的页面上可以用this.$route.query.plan拿到查询参数
10. this.$router.push()跳转后可以回退，上一个路由会被保存在浏览器的历史记录里；this.$router.replace()跳转后不可回退，上一个路由不会被保存在浏览器的历史记录里
11. 从远端拉下一个项目后，怎么run起来或继续开发：
    a. 安装nodejs(如果本机没有安装，若安装了可能还会有版本要求，这时就要升级node)（node -v 查看版本）
    b. 安装yarn（如果本机没有安装）（yarn -v 查看版本）（若yarn不是内部命令，则需要配环境变量：高级系统设置->环境变量->系统变量->编辑path->添加路径,如：C:\Users\tiger\AppData\Roaming\npm\node_modules\yarn\bin）
    c. 安装vue-cli（vue -V 查看版本）（若vue不是内部命令，则需要配环境变量：高级系统设置->环境变量->系统变量->编辑path->添加路径,如：C:\Users\tiger\AppData\Local\Yarn\bin）
    d. 在项目根目录执行yarn install
    e. 在执行yarn install时如果报错node_modules\node sass:Command failed.则需一次执行：
       npm install -g mirror-config-china --registry=http://registry.npm.taobao.org
       npm install node-sass
       yarn install
12. 设计图上的文本字体大小为10px：.text{font-size: 12px; transform: font scale(0.86);},设置12px,再缩小到10px（因为浏览器显示最小字体为12px,所以不能直接写font-size:10px）
13. .div1{width: max-content;} div1的宽度为其内容的最大宽度
14. $nextTick 将回调延迟到下次DOM更新循环之后执行，在修改数据之后立即调用它，然后等待DOM更新（$nextTick(function(){do something})）
15. 动态属性：在data中定义，通过this.属性名访问；静态属性：不在data中定义，直接写this.属性名=值，也是通过this.属性名访问，静态属性不会像动态属性那样呗绑定一些信息数据，它不能用在模板上渲染
16. 请求接口那会李图片不显示，在index.html中加<meta name="referrer" content="never">




三、工具
1. vue.js devtools (通过chrome市场安装的扩展程序)
2. yo框架 (需要安装 yarn add yo3) (这是基于react的组件库框架，这里我们只用它的样式部分)
   a. 安装完成后将根目录下的yo文件夹和package.json里的dependencies下的yo3都删除
   b. 将node_modules中的yo3文件夹中的style文件夹复制并黏贴到src文件夹中
   c. 项目的样式重置：在App.vue中的style中引入yo3的样式重置  @import './style/usage/core/reset.scss'; (不要忘了分号，App.vue的style不用写scoped)
   d. 在页面中使用：在style中引入@import '@/style/usage/core/reset.scss';   然后就可以使用了，如：.box{@include flexbox(); @include flex-direction(column)}
3. mint-ui组件库(在cli3中使用，cli3以前直接在.babelrc文件中配置)
   a. yarn add mint-ui
   b. yarn add babel-plugin-component -D
   c. 使用方法：
      方法1：在babel.config.js中添加配置 "plugins": [["component", {"libraryName": "mint-ui", "style": true}]]，
            在页面中引入组件import {Swipe, SwipeItem} from 'mint-ui'   然后再注入组件components:{[Swipe.name]: Swipe, [SwipeItem.name]: SwipeItem}  这样就使用了
      方法2：在main.js中引用：import MintUi from 'mint-ui'  import 'mint-ui/lib/style.css'  Vue.use(MintUi), 
            在页面使用(例如使用Button)：<mt-button :plain="true" @click="handleClick">开始体验</mt-button>
   注：最好使用方法1，哪里用就在哪里引入，避免不必要的载入
      方法1使用组件时只能使用mint-ui提供的默认的组件名，如：<mt-swipe></mt-swipe>, 
      方法2使用组件时可以在注入的时候自定义组件名，但最好使用mint-ui提供的默认的组件名，因为可能有样式绑定，[Swipe.name]是es6语法，[]是将一个变量的值取到作为字符串，Swipe.name的值就是mint-ui提供的Swipe的默认的组件名(mt-swipe)
4. axios(在vue中一般用axios来请求接口)  
   a. yarn add axios
   b. 在使用的页面引入：import axios from 'axios'
   d. 使用
5. iconfont的使用(结合yo使用)
   a. 打开iconfont.cn, 图标库 -> 官方图标库 -> 手机淘宝图标库 -> 寻找或搜索需要的图标 -> 加入购物车
   b. 选择完要的图标后，在购物车中点击下载代码 -> 下载完后解压 -> 将iconfont.ttf和iconfont.woff复制到assets文件夹下的iconfont里(新建一个iconfont文件夹)
   c. 打开下载后解压的文件夹，打开demo_index.html，查看iconfont
   d. 在使用页面的syle中定义font-face: 
      @font-face {
        font-family: 'yofont';
        src: 
          url('../assets/iconfont/iconfont.woff') format('woff'),
          url('../assets/iconfont/iconfont.ttf') format('truetype')
        }
    e. 给使用iconfont的标签添加class名yo-ico -> 将从demo_index.html查看到的某个图标的iconfont写在标签里
       <i class="yo-ico">&#xe612;</i>  注意：&#xe612;是html代码，不是文本
6. better-scroll
   a. yarn add better-scroll
   b. 在使用页面引入：import BScroll from 'better-scroll'
   c. 使用：mounted(){
            new BScroll('#id', { //id为容器id(class也可以)(容器要加width或height并且加overflow:hidden)，容器要保证只有一个子元素（不是孙元素）（子元素的宽或高要比容器大才能滚动）(如果有相同的id或class那么只会第一个有效)
                scrollX: true //横向
            })
           }
    d. 在better-scroll的滚动体中，默认是不能绑定事件的，如果要绑定则要在better-scroll初始化的时候改变对应事件的默认值：
       new BScroll('#id', {
            scrollX: true,
            click: true
        })



四、vuex
1. vuex是专为vue.js应用程序开发的状态管理模式(也就是专为vue.js设计的状态管理库)(实现vue组件的状态共享)
2. 原理： Components --dispatch(手动)--> Actions(backend API) --commit(自动)--> Mutations(devtools) --mutate(手动)--> State --render(自动)-- Components
3. 用法：
   a. 在src文件夹中创建store文件夹，在其中创建index.js
   b. 在index.js中引用vuex: 
        import Vue from 'vue'
        import Vuex from 'vuex'
        Vue.use(Vuex)
        export default new Vuex.Store({
            state: {
            },
            mutations: {
            },
            actions: {
            },
            modules: {
            }
        })
    c. 在main.js中引入：import store from './store/index.js'（index.js可以省略不写）
    d. 在组件中使用...mapState时需要抽离：import {mapState} from 'vuex'